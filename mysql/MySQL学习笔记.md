# MySQL 学习笔记

​    

### 存储引擎

MySQL 的索引是在存储引擎中实现的，不同的存储引擎支持的索引类型以及具体实现方式是有差别的。

常用的存储引擎包括 MYISAM，Innodb ， Memory 。其特点如下：

#### MYISAM

全表锁，拥有较高的执行速度，一个写请求请阻塞另外相同表格的所有读写请求，并发性能差，占用空间相对较小，不支持事务，5.5 以上支持全文索引。

#### Innodb

行级锁，并发能力相对强，占用空间是 MYISAM 的 2.5 倍，支持事务，5.6 开始支持全文索引。

#### Memory

全表锁，存储在内存当中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重启时会丢失。

​    

### 分表

#### 纵向分表

常见方式有根据活跃度分表、根据重要性分表等。

主要解决：

- 表与表之间资源争用问题；
- 锁争用机率小；
- 实现核心与非核心的分级存储，如UDB登陆库拆分成一级二级三级库；
- 数据库同步压力问题。

#### 横向分表

根据某些特定的规则来划分大数据量表，如根据时间分表。

主要解决：

- 单表过大造成的性能问题；
- 单表过大造成的单服务器空间问题。

​    

### 索引

MySQL 索引类型：

- 主键索引（PRIMARY）
- 唯一索引（UNIQUE）
- 普通索引（INDEX）
- 全文索引（FULLTEXT ，MYISAM 及 5.6 以上的 Innodb）

主键索引、唯一索引、普通索引都是基于 B-Tree 索引算法实现的。主键索引的字段不允许为 null ，且不能重复。唯一索引允许为 null ，但能重复。普通索引允许 null ，重复。

全文索引适用于海量数据的关键字模糊搜索，但功能还是比专业的搜索引擎少。

索引会加快查询速度，但不是越多越好，因为会增加数据库存储空间，并且插入修改数据时需要花时间去维护索引（5.5 以下的只能用到一个索引）。

联合索引

联合索引的效率往往比单列索引的效率高。

联合索引能够满足最左侧查询需求，例如(a, b, c)三列的联合索引，能够加速a | (a, b) | (a, b, c) 三组查询需求。

不建议频繁用 or ，不是所有的 or 都命中索引

union 不一定比 or 快

对于 != ，负向查询不会命中索引（除非量很小）

like %XX% 不能走索引，instr() 可以

in(a,b) 如果满足条件的数据占比非常大，也是有可能不用索引而是表扫描的

尽量避免在where字句中对字段进行null值的判断。否则将会导致引擎放弃使用索引而进行全表扫描

索引区分度法则：辨识度超过 20% 的属性，如果有查询需求，就建议建立索引

​    

### 优化

不要使用 select * （涉及到数据字典解析）

排序尽量使用升序

order by / group by 字段包括在索引当中减少排序，效率会更高

删除表所有记录请用 truncate ，不要用 delete

在 Innodb上用 select count(*) ，因为 Innodb 会存储统计信息

慎用 oder by rand()

​    

慢查询日志

​    

加锁，死锁

​    

缓存

​    

分页

越往后分页查询的效率越差