# 第17章 容器深入研究

​    

![thinking-in-java-FullContainerTaxonomy](../img/thinking-in-java-FullContainerTaxonomy.png)

​    

### Set

- 每个元素都必须是唯一的。所以加入 Set 的元素必须定义 `equals()` 方法以确保对象的唯一性；


- 不保证维护元素的次序。

#### HashSet

为快速查找而设计的 Set。元素必须定义 `hashCode()` 。

#### TreeSet

保持次序的 Set，底层为树结构。可以从 TreeSet 中提取有序的序列。元素必须实现 Comparable 接口（`compareTo()` 方法）。

##### compareTo()

比如判断两个 int 类型 i 与 j 时，不能直接 `return i-j;` 。因为 int 不够大，如果 i 是很大的正整数，而 j 是很大的负整数，i-j 就会溢出而返回负值。解决方法：`return (i < j ? -1 : (i == j ? 0 : 1));` 。

#### LinkedHashSet

具有 HashSet 的查询速度，且内部使用链表维护元素的顺序（按插入的次序）。元素必须定义 `hashCode()` 。

​     

### 队列 Queue

有 LinkedList（双向队列），PriorityQueue（优先级队列）。

​    

### Map

使用对象的 `hashCode()` 进行快速查询。

#### HashMap

比其他 Map 速度快。

#### LinkedHashMap

遍历时它的顺序是按插入次序或是按最近最少使用（LRU）的次序。由于使用链表维护次序，迭代访问时会比 HashMap 更快。

#### TreeMap

基于红黑树的实现（具有 `subMap()` 返回一个子树的方法）。元素会被排序（次序由 Comparable 或 Comparator 决定）。

#### ConcurrentHashMap

线程安全的 Map。

#### WeakHashMap

弱键映射。允许释放映射所指向的对象。

#### IdentityHashMap

使用 == 代替 `equals()` 对键进行比较的散列映射。

​    

