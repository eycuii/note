# 第21章 并发

​    

## 基本的线程机制

### 定义任务

实现 Runnable 接口并编写 `run()` 方法。

```java
public class LiftOff implements Runnable {
  protected int countDown = 10; // Default
  private static int taskCount = 0;
  private final int id = taskCount++;
  public LiftOff() {}
  public LiftOff(int countDown) {
    this.countDown = countDown;
  }
  public String status() {
    return "#" + id + "(" +
      (countDown > 0 ? countDown : "Liftoff!") + "), ";
  }
  public void run() {
    while(countDown-- > 0) {
      System.out.print(status());
      Thread.yield();
    }
  }
}
```

**启动：**

```java
// 第一种
LiftOff launch = new LiftOff();
launch.run();
// 第二种
Thread t = new Thread(new LiftOff());
t.start();
```

​    

### Executor

一个 Executor 可以启动多个线程。

```java
ExecutorService exec = Executors.newCachedThreadPool();
// 或：
// ExecutorService exec = Executors.newFixedThreadPool(5);
for(int i = 0; i < 5; i++)
    exec.execute(new LiftOff());
exec.shutdown();
```

除了 CachedThreadPool ，还有 FixedThreadPool ，可以限定线程数量。SingleThreadExecutor 则只有一个线程的 FixedThreadPool 。

newCachedThreadPool() 可以传自己实现的 ThreadFactory，如：

```java
public class MyThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    Thread t = new Thread(r);
    // ...
    return t;
  }
}
```

​    

### Callable 接口

Runnable 的 `run()` 方法不能有返回值，而 Callable 可以有。通过泛型指定其返回值类型。

```java
class TaskWithResult implements Callable<String> {
  private int id;
  public TaskWithResult(int id) {
    this.id = id;
  }
  public String call() {
    return "result of TaskWithResult " + id;
  }
}

public class CallableDemo {
  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    ArrayList<Future<String>> results = new ArrayList<Future<String>>();
    for(int i = 0; i < 10; i++)
      results.add(exec.submit(new TaskWithResult(i)));
    for(Future<String> fs : results)
      try {
        // get() blocks until completion:
        System.out.println(fs.get());
      } catch(Exception e) {
        System.out.println(e);
        return;
      } finally {
        exec.shutdown();
      }
  }
}
```

​    

### 休眠

```java
TimUnit.MILLISECONDES.sleep(100);
```

注：`sleep()` 方法可能会抛出 InterruptedException，如果在 `run()` 方法中进行休眠，由于异常不能抛给 main 方法，所以需要在 `run()` 中进行捕获。

​    

### 优先级

调度器会倾向于让优先级高的线程先执行，但不意味着优先级低的被死锁，只是执行的频率较低而已。

JDK 有 10 个优先级，但有些操作系统的优先级并不是 10 个，所以最好使用 MAX_PRIORITY ，NORM_PRIORITY ，MIN_PRIORITY 这三种。

```java
public class SimplePriorities implements Runnable {
  private int countDown = 5;
  private volatile double d; // No optimization
  private int priority;
  public SimplePriorities(int priority) {
    this.priority = priority;
  }
  public String toString() {
    return Thread.currentThread() + ": " + countDown;
  }
  public void run() {
    Thread.currentThread().setPriority(priority);
    while(true) {
      // An expensive, interruptable operation:
      for(int i = 1; i < 100000; i++) {
        d += (Math.PI + Math.E) / (double)i;
        if(i % 1000 == 0)
          Thread.yield(); // 向调度器声明可以切换给其他线程执行。但不能保证一定会切换。
      }
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    for(int i = 0; i < 5; i++)
      exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
    exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
    exec.shutdown();
  }
} /* Output: (70% match)
Thread[pool-1-thread-6,10,main]: 5
Thread[pool-1-thread-6,10,main]: 4
Thread[pool-1-thread-6,10,main]: 3
Thread[pool-1-thread-6,10,main]: 2
Thread[pool-1-thread-6,10,main]: 1
Thread[pool-1-thread-3,1,main]: 5
Thread[pool-1-thread-2,1,main]: 5
Thread[pool-1-thread-1,1,main]: 5
Thread[pool-1-thread-5,1,main]: 5
Thread[pool-1-thread-4,1,main]: 5
...
*/
```

​    

### 后台线程

可以通过 `setDaemon(true)` 指定为后台进程。

所有非后台线程运行结束时，程序会杀掉全部后台线程。

以下例子中，程序大约在 3 秒后所有后台线程将被终止。

```java
public class SimpleDaemons implements Runnable {
  public void run() {
    try {
      while(true) {
        TimeUnit.MILLISECONDS.sleep(100);
        print(Thread.currentThread() + " " + this);
      }
    } catch(InterruptedException e) {
      print("sleep() interrupted");
    }
  }
  public static void main(String[] args) throws Exception {
    for(int i = 0; i < 10; i++) {
      Thread daemon = new Thread(new SimpleDaemons());
      daemon.setDaemon(true); // Must call before start()
      daemon.start();
    }
    print("All daemons started");
    TimeUnit.MILLISECONDS.sleep(3000);
  }
}
```

注：如果后台线程 run() 方法中有 finally 子句，也不一定会执行。

​    

### 术语：任务与线程

由继承 Thread 或实现 Runnable 接口的是一个任务，而非线程。

线程是被某种方式附着到任务上，而使得可以驱动任务的。

​    

### join() 加入另一个线程

`join()` 方法可以让一个线程在某线程上调用，指等待线程结束后才恢复而继续执行（即线程将被挂起）。

可以设置超时参数，超过时返回 `join()` 方法。

```java
class Sleeper extends Thread {
  private int duration;
  public Sleeper(String name, int sleepTime) {
    super(name);
    duration = sleepTime;
    start();
  }
  public void run() {
    try {
      sleep(duration);
    } catch(InterruptedException e) {
      print(getName() + " was interrupted. " +
        "isInterrupted(): " + isInterrupted());
      return;
    }
    print(getName() + " has awakened");
  }
}

class Joiner extends Thread {
  private Sleeper sleeper;
  public Joiner(String name, Sleeper sleeper) {
    super(name);
    this.sleeper = sleeper;
    start();
  }
  public void run() {
   try {
      sleeper.join();
    } catch(InterruptedException e) {
      print("Interrupted");
    }
    print(getName() + " join completed");
  }
}

public class Joining {
  public static void main(String[] args) {
    Sleeper
      sleepy = new Sleeper("Sleepy", 1500),
      grumpy = new Sleeper("Grumpy", 1500);
    Joiner
      dopey = new Joiner("Dopey", sleepy),
      doc = new Joiner("Doc", grumpy);
    grumpy.interrupt();
  }
}/* Output:
Grumpy was interrupted. isInterrupted(): false
Doc join completed
Sleepy has awakened
Dopey join completed
*/
```

​    

### 捕获异常

由于线程的特性，如果 `run()` 抛出了异常，即使在 main 方法中捕获也不能保证能捕获成功。

所以捕获线程的异常需要使用 Thread.UncaughtExceptionHandler 的 `uncaughtException()` 方法。

```java
class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
  public void uncaughtException(Thread t, Throwable e) {
    System.out.println("caught " + e);
  }
}

class HandlerThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
    return t;
  }
}
```

利用 HandlerThreadFactory 创建的线程，其抛出的异常可以被捕获。

如果代码中全部都使用相同的异常处理器，可以给 Thread 设置默认的异常处理器：

```java
public static void main(String[] args) {
    // 设置默认异常处理器（defaultUncaughtExceptionHandler 是静态的）
    Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new ExceptionThread());
}
```

线程在没有专门设置一个异常处理器时，会使用该默认异常处理器。

​    

## 共享受限资源

### synchronized

锁住的是对象。

注意，`static synchronized` 方法由于是静态的，锁住的不是 this 对象，而是该类的 Class 对象。所以相当于是全局锁（即该类所有对象都将等待该方法释放 Class 对象锁）。

如果要利用 synchronized 代码块实现全局锁，简单的方法：`synchronized(Xxx.class){}`



### Lock 对象

需要显式的创建、锁定、释放 Lock 对象。

```java
private Lock lock = new ReentrantLock();
public int next() {
    lock.lock();
    try {
        // ...
        return currentEvenValue; // return后执行finally，从而避免过早解锁
    } finally {
        lock.unlock();
    }
}
```

与 synchronized 比较，虽然复杂，但细粒度小，而且可以实现获取锁失败时的操作等功能。



### 原子性

具有原子性的操作不会被线程机制而中断。

原子性可以应用于 long 和 double 之外的所有基本类型上的简单操作（比如读取和写入，i++、i+=1 不算）。

由于 long 和 double 是 64 位的，JVM 会把它分成两个 32 位来操作，所以如果要实现原子性，可以使用 volatile 关键字。

原子类：AtomicInteger，AtomicLong，AtomicReference 等。

### 可见性

不可见性：一个线程中对某变量进行了修改但只存到本地缓存中，导致到另一个线程获取该变量时并不是修改后的最新的值。

如果使用 volatile 关键字，即使使用了本地缓存，也会立即被写入到主存中，从而可以实现可见性。

但注意，使用 volatile 而不是 synchronized 的唯一情况是：类中只有一个可变的域。第一选择应该最好是使用 synchronized。

​    

### ThreadLocal 线程本地存储

可以为使用相同变量的每个不同线程都拥有不同的存储。



## 终结任务

### 线程状态

新建，就绪，阻塞，死亡。

​    

### 阻塞原因

1. 通过 sleep() 进入休眠状态。
2. 调用 wait() 使线程挂起。直到 notify() 或 notifyAll() 而进入就绪状态。
3. 任务在等待某个输入 / 输出完成。
4. 死锁。

​    

### 中断 

`thread.interrupt()`：中断线程。线程被阻塞时，中断线程将抛出 InterruptedException 异常。

`Thread.interrupted()`：是否被中断。

注：I/O 和 synchronized 同步块在阻塞时一般不能被中断。（除非 I/O 被 `close()` 而中断或使用 NIO）

```java
try {
    while(!Thread.interrupted()) {
        try {
            // 会导致阻塞的操作
        } finally {
            // 被中断时，先进行finally之后将进入catch块
            // 可以进行清理等操作
        }
    }
} catch(InterruptedException e) {
    print("Exiting via InterruptedException");
}
```

