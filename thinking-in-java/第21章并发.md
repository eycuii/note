# 第21章 并发

​    

## 基本的线程机制

### 定义任务

实现 Runnable 接口并编写 `run()` 方法。

```java
public class LiftOff implements Runnable {
  protected int countDown = 10; // Default
  private static int taskCount = 0;
  private final int id = taskCount++;
  public LiftOff() {}
  public LiftOff(int countDown) {
    this.countDown = countDown;
  }
  public String status() {
    return "#" + id + "(" +
      (countDown > 0 ? countDown : "Liftoff!") + "), ";
  }
  public void run() {
    while(countDown-- > 0) {
      System.out.print(status());
      Thread.yield();
    }
  }
}
```

**启动：**

```java
// 第一种
LiftOff launch = new LiftOff();
launch.run();
// 第二种
Thread t = new Thread(new LiftOff());
t.start();
```

​    

### Executor

一个 Executor 可以启动多个线程。

```java
ExecutorService exec = Executors.newCachedThreadPool();
// 或：
// ExecutorService exec = Executors.newFixedThreadPool(5);
for(int i = 0; i < 5; i++)
    exec.execute(new LiftOff());
exec.shutdown();
```

除了 CachedThreadPool ，还有 FixedThreadPool ，可以限定线程数量。SingleThreadExecutor 则只有一个线程的 FixedThreadPool 。

newCachedThreadPool() 可以传自己实现的 ThreadFactory，如：

```java
public class MyThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    Thread t = new Thread(r);
    // ...
    return t;
  }
}
```

​    

### Callable 接口

Runnable 的 `run()` 方法不能有返回值，而 Callable 可以有。通过泛型指定其返回值类型。

```java
class TaskWithResult implements Callable<String> {
  private int id;
  public TaskWithResult(int id) {
    this.id = id;
  }
  public String call() {
    return "result of TaskWithResult " + id;
  }
}

public class CallableDemo {
  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    ArrayList<Future<String>> results = new ArrayList<Future<String>>();
    for(int i = 0; i < 10; i++)
      results.add(exec.submit(new TaskWithResult(i)));
    for(Future<String> fs : results)
      try {
        // get() blocks until completion:
        System.out.println(fs.get());
      } catch(Exception e) {
        System.out.println(e);
        return;
      } finally {
        exec.shutdown();
      }
  }
}
```

​    

### 休眠

```java
TimUnit.MILLISECONDES.sleep(100);
```

注：`sleep()` 方法可能会抛出 InterruptedException，如果在 `run()` 方法中进行休眠，由于异常不能抛给 main 方法，所以需要在 `run()` 中进行捕获。

​    

### 优先级

调度器会倾向于让优先级高的线程先执行，但不意味着优先级低的被死锁，只是执行的频率较低而已。

JDK 有 10 个优先级，但有些操作系统的优先级并不是 10 个，所以最好使用 MAX_PRIORITY ，NORM_PRIORITY ，MIN_PRIORITY 这三种。

```java
public class SimplePriorities implements Runnable {
  private int countDown = 5;
  private volatile double d; // No optimization
  private int priority;
  public SimplePriorities(int priority) {
    this.priority = priority;
  }
  public String toString() {
    return Thread.currentThread() + ": " + countDown;
  }
  public void run() {
    Thread.currentThread().setPriority(priority);
    while(true) {
      // An expensive, interruptable operation:
      for(int i = 1; i < 100000; i++) {
        d += (Math.PI + Math.E) / (double)i;
        if(i % 1000 == 0)
          Thread.yield(); // 向调度器声明可以切换给其他线程执行。但不能保证一定会切换。
      }
      System.out.println(this);
      if(--countDown == 0) return;
    }
  }
  public static void main(String[] args) {
    ExecutorService exec = Executors.newCachedThreadPool();
    for(int i = 0; i < 5; i++)
      exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
    exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
    exec.shutdown();
  }
} /* Output: (70% match)
Thread[pool-1-thread-6,10,main]: 5
Thread[pool-1-thread-6,10,main]: 4
Thread[pool-1-thread-6,10,main]: 3
Thread[pool-1-thread-6,10,main]: 2
Thread[pool-1-thread-6,10,main]: 1
Thread[pool-1-thread-3,1,main]: 5
Thread[pool-1-thread-2,1,main]: 5
Thread[pool-1-thread-1,1,main]: 5
Thread[pool-1-thread-5,1,main]: 5
Thread[pool-1-thread-4,1,main]: 5
...
*/
```

​    

### 后台线程

可以通过 `setDaemon(true)` 指定为后台进程。

所有非后台线程运行结束时，程序会杀掉全部后台线程。

以下例子中，程序大约在 3 秒后所有后台线程将被终止。

```java
public class SimpleDaemons implements Runnable {
  public void run() {
    try {
      while(true) {
        TimeUnit.MILLISECONDS.sleep(100);
        print(Thread.currentThread() + " " + this);
      }
    } catch(InterruptedException e) {
      print("sleep() interrupted");
    }
  }
  public static void main(String[] args) throws Exception {
    for(int i = 0; i < 10; i++) {
      Thread daemon = new Thread(new SimpleDaemons());
      daemon.setDaemon(true); // Must call before start()
      daemon.start();
    }
    print("All daemons started");
    TimeUnit.MILLISECONDS.sleep(3000);
  }
}
```

注：如果后台线程 run() 方法中有 finally 子句，也不一定会执行。

​    

### 术语：任务与线程

由继承 Thread 或实现 Runnable 接口的是一个任务，而非线程。

线程是被某种方式附着到任务上，而使得可以驱动任务的。

​    

### join() 加入另一个线程

`join()` 方法可以让一个线程在某线程上调用，指等待线程结束后才恢复而继续执行（即线程将被挂起）。

可以设置超时参数，超过时返回 `join()` 方法。

```java
class Sleeper extends Thread {
  private int duration;
  public Sleeper(String name, int sleepTime) {
    super(name);
    duration = sleepTime;
    start();
  }
  public void run() {
    try {
      sleep(duration);
    } catch(InterruptedException e) {
      print(getName() + " was interrupted. " +
        "isInterrupted(): " + isInterrupted());
      return;
    }
    print(getName() + " has awakened");
  }
}

class Joiner extends Thread {
  private Sleeper sleeper;
  public Joiner(String name, Sleeper sleeper) {
    super(name);
    this.sleeper = sleeper;
    start();
  }
  public void run() {
   try {
      sleeper.join();
    } catch(InterruptedException e) {
      print("Interrupted");
    }
    print(getName() + " join completed");
  }
}

public class Joining {
  public static void main(String[] args) {
    Sleeper
      sleepy = new Sleeper("Sleepy", 1500),
      grumpy = new Sleeper("Grumpy", 1500);
    Joiner
      dopey = new Joiner("Dopey", sleepy),
      doc = new Joiner("Doc", grumpy);
    grumpy.interrupt();
  }
}/* Output:
Grumpy was interrupted. isInterrupted(): false
Doc join completed
Sleepy has awakened
Dopey join completed
*/
```

​    

### 捕获异常

由于线程的特性，如果 `run()` 抛出了异常，即使在 main 方法中捕获也不能保证能捕获成功。

所以捕获线程的异常需要使用 Thread.UncaughtExceptionHandler 的 `uncaughtException()` 方法。

```java
class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
  public void uncaughtException(Thread t, Throwable e) {
    System.out.println("caught " + e);
  }
}

class HandlerThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
    return t;
  }
}
```

利用 HandlerThreadFactory 创建的线程，其抛出的异常可以被捕获。

如果代码中全部都使用相同的异常处理器，可以给 Thread 设置默认的异常处理器：

```java
public static void main(String[] args) {
    // 设置默认异常处理器（defaultUncaughtExceptionHandler 是静态的）
    Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
    ExecutorService exec = Executors.newCachedThreadPool();
    exec.execute(new ExceptionThread());
}
```

线程在没有专门设置一个异常处理器时，会使用该默认异常处理器。

​    

