# 第5章 初始化与清理



（88）JVM并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。



### finalize



## 垃圾回收

#### 引用计数法

当有新的引用指向某对象时就将该对象的引用计数加一，当指向该对象的引用被销毁时将该计数减一，当计数归零时，就回收该对象所占用的内存资源。

缺点：会有循环引用问题，所以 java 没有使用该方法。循环引用的例子：

```java
class A{
  public B b;
   
}
class B{
  public A a;
}
public class Main{
    public static void main(String[] args){
    A a = new A();
    B b = new B();
    a.b=b;
    b.a=a;
    }
}
```

在函数的结尾，a 和 b 的计数均为 2。

先撤销 a ，然后 a 的计数为 1，在等待 b.a 对 a 的引用的撤销，也就是在等待 b 的撤销。

对于 b 来讲，也是同理，两个对象都在等待对方撤销，所以这两个资源均不能释放。



#### 标记-清扫（mark and sweep）

先遍历所有的引用，标记所有被引用的对象。清理时只释放没有被标记的对象，所以堆空间会是不连续的，从而会产生内存碎片。



#### 停止-复制（stop and copy）

有两个堆，先暂停运行程序，把所有被引用的对象复制到另一个堆，没有被复制的都会被释放。复制到新堆后，对象是挨着的，所以不会产生内存碎片，但效率低。



#### 代数（generation count）

内存分配以块为单位（如果对象较大，它会单独占用一个块）。停止-复制方式在回收时可以往废弃的块里复制对象，而不用每次复制大量内存。

每个块都有它的代数，如果块在某处被引用，则其代数会增加。



#### 自适应：结合标记-清扫与停止-复制方法

先使用标记-清扫方式，若内存碎片多，则切换回停止-复制方式。如果所有对象都很稳定，则再回到标记-清扫方式。