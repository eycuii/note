# 第2章 Java 并发机制的底层实现原理

Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终需要转化为汇编指令在 CPU 上执行，Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。 

​    

## volatile

1) 将当前处理器缓存行的数据直接写回到系统内存。 

2) 这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效（过期）。这样其他处理器进行修改操作时，会重新从系统内存中读取数据到处理器缓存里。

### volatile 的使用优化

jdk 7 并发包里新增的一个队列集合类 LinkedTransferQueue：

```java
/** 队列中的头部节点 */
private transient final PaddedAtomicReference<QNode> head;
/** 队列中的尾部节点 */
private transient final PaddedAtomicReference<QNode> tail;
static final class PaddedAtomicReference <T> extends AtomicReference T> {
    // 使用很多4个字节的引用追加到64个字节
  	// （一个对象的引用占 4 个字节，它追加了 15 个变量（共占 60 个字节），再加上父类的 value 变量，一共 64 个字节）
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
    PaddedAtomicReference(T r) {
      super(r);
    }
}
public class AtomicReference <V> implements java.io.Serializable {
    private volatile V value;
    // 省略其他代码
｝
```

它在使用 volatile 变量时，用一种追加字节的方式来优化队列出队和入队的性能。 

​    

**为什么追加 64 字节能够提高并发编程的效率呢？** 

缓存的高速缓存行（缓存的最小操作单位）是 64 个字节，且不支持不足部分填充缓存行。如果队列的头结点和尾节点都不足 64 字节，处理器会将它们都放到同一个缓存行中。而当一个处理器试图修改头结点时，会将整个缓存行锁定，那么会导致其他处理器不能访问自己高速缓存行中的尾节点。队列的入队、出队操作都需要不停修改头结点、尾节点，所以多处理器的情况下会严重影响到入队、出队效率。使用追加到 64 个字节的方式来手动填满缓存行，就能避免这种情况。

​    

**那么是不是在使用 volatile 变量时都应该追加到 64 字节呢？**

不是的。在两种场景下不应该使用这种方式。

- 缓存行非 64 字节宽的处理器。
- 共享变量不会被频繁地写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。 

​    

## synchronized

锁：

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的 Class 对象。
- 对于同步方法块，锁是 synchonized 括号里配置的对象。 

​    

## 原子操作的实现原理

### 处理器如何实现原子操作

处理器实现原子操作的两种机制：

#### 总线锁

当一个处理器在总线上发出 Lock#信号，其他处理器的请求会被阻塞。

缺点：其他处理器不能操作其他内存地址的数据，所以开销较大。

#### 缓存锁

处理器回写到内存时，会直接修改内部的内存地址，使其他处理器回写时让其缓存行无效（过期）。

但是有两种情况下处理器不会使用缓存锁定：

1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。 
2. 有些处理器不支持缓存锁定。 

​    

### Java 如何实现原子操作 

在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 

#### CAS 的三大问题

**1. ABA问题**

JDK 的 Atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的 compareAndSet 方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**2. 循环时间长开销大** 

> 自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令，那么效率会有一定的提升。pause 指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起 CPU 流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。 

**3. 只能保证一个共享变量的原子操作**

这种情况可以用锁。获取多个共享变量合并成一个共享变量。JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把多个变量放在一个对
象里来进行 CAS 操作。 

