# 第5章 Java 中的锁

​    

## Lock 接口

比起 synchronized，Lock 可以：

1. 响应中断，被中断时抛出中断异常并释放锁；
2. 超时获取（tryLock(long time, TimeUnit unit)），指定时间内未获取锁时可以返回；
3. 非阻塞地获取锁（tryLock()），调用会立即返回，如果能获取则返回 true，否则返回 false。

​    

## AbstractQueuedSynchronizer 队列同步器

为 Lock 的实现类提供使用。可以根据它的状态值实现独占锁等功能的 Lock。

内部有同步队列（FIFO）。队列中的节点包含线程引用、等待状态、前节点、后节点等，每次 acquire() 会将头结点出队，线程获取同步状态失败时构造成节点加到同步队列中。

独占式同步状态获取流程，也就是 acquire(int arg) 方法调用流程 ：

![java并发编程的艺术-独占式同步状态获取流程](..\img\java并发编程的艺术-独占式同步状态获取流程.png)

如上图，acquire() 方法会使每个节点（/ 线程）进入自旋的状态。

总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点（为了保证 FIFO）且成功获取了同步状态。在释放同步状态时，同步器调用 tryRelease(int arg) 方法释放同步状态，然后唤醒头节点的后继节点。 

​    

## ReentrantLock 重入锁

像 synchronized 那样，线程获得锁后可以继续重复获得锁，并不会阻塞。

可以选择获取锁时要公平性还是非公平性。默认为非公平的，因为公平的需要反复切换线程。

​    

## ReentrantReadWriteLock 读写锁

同一时刻允许多个读线程进行访问，但写线程访问时，其他所有读、写线程都会被阻塞。

支持公平、非公平（默认）的所获取方式。

可以重进入。

拥有读锁和写锁。

支持锁降级，不支持锁升级（会造成数据不可见的问题）。

​    

## LockSupport 工具类

提供阻塞、唤醒线程的基础工具类。

​    

## Condition 接口

Condition 对象由 Lock 对象创建出来（Lock 对象的 newCondition() 方法）。

提供等待、唤醒线程等方法。