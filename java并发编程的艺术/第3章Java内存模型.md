# 第3章 Java 内存模型

​    

## Java 内存模型（JMM）的抽象结构

![java并发编程的艺术-Java内存模型的抽象结构](..\img\java并发编程的艺术-Java内存模型的抽象结构.png)

​    

## 指令重排序

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分 3 种类型：

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 

从 Java 代码到最终执行的指令序列，会分别经理上面 3 种重排序。

对于处理器重排序（后两种重排序），JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel 称之为 Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。 

JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 

​    

## happens-before

在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 

​    

## final

### 为什么 final 引用不能从构造函数内“溢出”

​    

