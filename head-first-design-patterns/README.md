（610 页）

| 模式     | 描述                                               |
| -------- | -------------------------------------------------- |
| 装饰者   | 包装一个对象，以提供新的行为。                     |
| 状态     | 封装了基于状态的行为，并使用委托在行为之间切换。   |
| 迭代器   | 在对象的集合之中游走，而不暴露集合的实现。         |
| 外观     | 简化一群类的接口。                                 |
| 策略     | 封装可以互换的行为，并使用委托来决定要使用哪一个。 |
| 代理     | 包装对象，以控制对此对象的访问。                   |
| 工厂方法 | 由子类决定要创建的具体类是哪一个。                 |
| 适配器   | 封装对象，并提供不同的接口。                       |
| 观察者   | 让对象能够在状态改变时被通知。                     |
| 模板方法 | 由子类决定如何实现一个算法中的某步骤。             |
| 组合     | 客户用一致的方式处理对象集合及其每个对象。         |
| 单例     | 有且只有一个对象被创建。                           |
| 抽象工厂 | 允许客户创建对象的家族，而无需指定他们的具体类。   |
| 命令     | 将请求封装成对象。                                 |

其他模式（附录）

| 模式                                          | 描述                                                         |
| --------------------------------------------- | :----------------------------------------------------------- |
| 桥接模式（Bridge Pattern）                    |                                                              |
| 生成器模式（Builder Pattern）                 | 封装一个对象的生产过程，允许按步骤生产。                     |
| 责任链模式（Chain of Responsibility Pattern） | 让多个对象能够处理某个请求。（为某个请求创建一个对象链，让这些对象按序处理（也可以判断不处理），并继续传给链中的下一个对象。） |
| 蝇量模式（Flyweight Pattern）                 |                                                              |
| 解释器模式（Interpreter Pattern）             |                                                              |
| 中介者模式（Mediator Pattern）                | 让中介者类的对象集中处理不同类的对象之间的逻辑。（每个对象出现某种事件时向中介者通知，中介者再根据判断然后通知其他类的对象。） |
| 备忘录模式（Memento Pattern）                 |                                                              |
| 原型模式（Prototype Pattern）                 | 使用 clone() 或反序列化创建实例。                            |
| 访问者模式（Visitor Pattern）                 | 封装一些作用于某种数据结构（比如树、集合）中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。（比如组合类里有对象list，这个类提供一个方法 accept(Visiotr visitor) { visitor.visit(entry) }，使访问者可以访问（遍历）此组合类里的所有对象。） |

