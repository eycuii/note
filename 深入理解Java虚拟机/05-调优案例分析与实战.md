# 第5章 调优案例分析与实战

​    

## 案例分析

### 高性能硬件上的程序部署策略

在提高服务器硬件时，主要有两种方式：

- 用 64 位 JDK，并使用大内存；
- 用若干个 32 位虚拟机建立逻辑集群来利用硬件资源（负载均衡）；

第一种方案，扩大服务器内存大小时，有可能出现由于过大的堆内存进行 GC 时带来的长时间的停顿。

对于用户交互性强、对停顿时间敏感的系统，分配大堆时需要把 Full GC 频率控制得足够低，使不会影响到用户体验。控制 Full GC 频率关键是，大部分对象的生存时间不应太长，尤其是生成时间长的大对象。

还有其他可能的问题是：1. 堆溢出时可能因为要生成很大的 dump 文件，导致无法产生堆转储快照，所以程序需要足够稳定；2. 64 位 JDK 的性能可能比 32 位还低；

所以不少人选择了第二种方案。具体做法是，在一台机器上启动多个应用服务器进程，每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器，以反向代理方式来分配请求。

### 集群间同步导致的内存溢出

### 堆外内存导致的溢出错误

本地方法使用的直接内存。

直接内存只能等待老年代满了之后 Full GC，然后顺便回收直接内存的垃圾。否则，会报内存溢出异常。

可通过参数控制直接内存大小。

除此之外，比如 Socket 缓冲区中连接过多的时候，如果无法分配内存，可能会抛出 IOException: Too many open files 异常。

### 外部命令导致系统缓慢

CPU 资源过高而发现并不是应用的进程，而是 fork 系统调用（fork 是在 Linux 中用来创建进程用的）。

分析发现，是因为每个用户请求时后台调用了 Runtime.getRuntime().exec() （获得系统的一些信息）方法所导致的。这个方法执行的就是 shell 脚本，即外部命令。它会首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新进程去执行外部命令，最后再推出这个进程。

最后，改为使用 Java 的 API 去获取了信息。

### 服务器 JVM 进程崩溃

发现频繁出现虚拟机自动关闭的现象，且留下一个 hs_err_pid###.log 文件后进程就消失了。从日志中看到，崩溃前不久，都会发生大量相同的异常，如 java.net.SocketException: Connection reset，是一个远端断开连接的异常。

最后发现是调用的 API 服务提供方返回速度过慢，而服务器等待线程和 Socket 连接越来越多所导致的，所以让服务提供方去进行了优化。

### 不恰当数据结构导致内存占用过大

应用中需要隔段时间进行加载大对象到内存进行分析，所以导致了停顿时间过长。

要根据使用的垃圾回收器进行分析，如果用的是复制方法，在不修改代码的情况下，可以修改 GC 参数去解决。比如把 Survivor 空间去掉，让新生代中存活的对象在第一次 Minor GC 后直接进入老年代，等到 Major GC 的时候再清理它们。然而这种方法只是治标不治本，关键还得修改代码实现。

### 由 Windows 虚拟内存导致的长时间停顿

​    

## 实战：Eclipse 运行速度调优

