# 第12章 Java内存模型与线程

​    

## 硬件的效率与一致性

高速缓存 Cache：由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以就加入了一层读写速度尽可能接近处理器运算速度的高速缓存，来作为内存与处理器之间的缓冲（将运算需要使用到的数据先复制到缓存中，运算结束后再从缓存同步到内存中）。

但这样会引入一个问题：**缓存一致性**。每个处理器都有自己的高速缓存，而它们又共享同一个主内存（Main Memory），这样会导致各自的缓存数据不一致。

​    

## Java 内存模型 JMM

Java 虚拟机规范定义了一种 Java 内存模型来屏蔽掉内存访问的差异，以实现 Java 程序在各种平台下都能达到一致的内存访问结果。

这个 Java 内存模型需要定义得足够严谨，才能让 Java 并发访问内存的操作不好产生歧义；但也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去优化。

所以，Java 内存模型的主要目标，就是定义**程序中各个变量的访问规则**。

### 主内存与工作内存

Java 内存模型规定了所有的变量都存储在虚拟机的**主内存**中。

每个线程都有自己的**工作内存**（Working Memory），保存了线程使用到的变量的主内存副本拷贝（拷贝对象的引用、某个字段，而不是整个对象都拷贝一次）。线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存。而且，不同的线程之间也不能直接访问对方工作内存，只能先通过主内存。

这里的主内存，与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，但如果硬要讲，那主内存主要对应于 Java 堆中的对象实例部分（除了实例，堆还有其他数据。对于 HotSpot，还有 Mark Word（对象的哈希码、GC 标志、GC 年龄、同步锁等）、Klass Point（指向存储类型元数据的指针）及一些用于字节对齐补白的填充数据）。而工作内存则对应于虚拟机栈中的部分区域。

从更低的层次上说，主内存就直接对应于物理硬件的内存。而为了更好的运行速度，虚拟机可能会让工作内存先存储于寄存器、高速缓存中。

### 内存间交互操作

