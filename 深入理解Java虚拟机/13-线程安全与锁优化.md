# 第13章 线程安全与锁优化

​    

## 线程安全

### Java 语言中的线程安全

可以将 Java 语言中各种操作共享的数据分为 5 类：

#### 不可变 Immutable

不可变对象一定是线程安全的。

如 String、枚举类型、java.lang.Number 的部分子类（如 Long、Double、BigDecimal 等）。

#### 绝对线程安全

#### 相对线程安全

通常所讲的线程安全。保证对这个对象单独的操作是线程安全的。但是对于一些特定顺序的连续调用，就可能不是线程安全的，需要额外使用同步手段。如 Vector、HashTable 等。

#### 线程兼容

对象本身不是线程安全的，但可以通过调用端正确地使用同步手段来保证安全地使用。

平常说一个类不是线程安全的，大部分就是指这种情况。

#### 线程对立

无论是否采取了同步措施，都无法并发使用的代码。Java 中很少出现。

### 线程安全的实现方法

#### 互斥同步（悲观锁）

**synchronized**

Java 中最基本的同步手段：synchronized。synchronized 经过编译后，会在同步块的前后生成 monitorenter 和 monitorexit 两个字节码指令。这两个字节码都需要一个 reference 类型的参数（要锁定/解锁的对象）。如果 synchronized 有明确指定对象，那参数就是这个对象的 reference；反之，如果是实例方法就是对象实例，如果是类方法就是 Class 对象。

monitorenter：尝试获取对象的锁。如果没被锁定，或者当前线程已经拥有了该对象的锁，会把锁的计数器加 1；

monitorexit：减 1；当计数器为 0 时锁就会被释放。所以 synchronized 是可重入的。

但是，12 章也有讲过，由于 Java 线程是映射到操作系统的原生线程上的，阻塞/唤醒一个线程都需要操作系统来完成，这时需要从用户态转换到和心态中，因此，状态转换需要耗费很多处理器时间。

**ReentrantLock 重入锁**

与 synchronized 相比，增加了一些功能：

- 等待可中断。长期等待时可以选择放弃等待。
- 公平锁。多个线程按申请锁的时间顺序获得锁。synchronized 中的锁是非公平的。ReentrantLock 默认是非公平的，但可以设置。
- 可以绑定多个条件（Condition）。

#### 非阻塞同步（乐观锁）

CAS 操作。

sun.misc.Unsafe 的 compareAndSwapInt() 等方法有提供，它们使用的就是操作系统提供的 CAS 指令。但并不是提供给用户程序调用的类。Unsafe.getUnsafe() 方法有限制只有启动类加载器加载的 Class 才能访问它。所以，如果不使用反射手段，只能通过如原子类等方法使用 Unsafe 的 CAS 操作。

对于 ABA 问题，提供了 AtomicStampedReference，通过变量值的版本来保证正确性。但其实对于该问题，可以改用互斥同步可能会比原子类更高效。

#### 无同步方案

没有共享的数据。

如使用 ThreadLocal。

​    

## 锁优化

HotSpot 上使用的锁优化技术。

### 自旋锁与自适应自旋

自旋锁虽然能避免线程切换的开销，但它会占用处理器时间。因此，如果锁被占用的时间很短，自旋等待的效果就好非常好。否则，就会白白消耗处理器资源，更耗性能。所以需要加下限制，如超过限制自旋的次数，就直接挂起线程。可使用 -XX:PreBlockSpin 来修改限制次数，默认是 10 次。

在 JDK 1.6 中引入了自适应的自旋锁。如果同一个锁对象上，有个线程刚刚拿到锁正在运行中，会把自旋等待时间持续相对更长的时间（次数）。如果，某个锁，自旋很好能成功获得锁，那就可能以后直接挂起线程。

### 锁消除

虚拟机即时编译器在运行时，如果某个同步代码里，检测到不存在共享数据竞争时，会把锁消除。其主要判定依据来源于逃逸分析（11章）的数据。（在一段代码中，如果堆上的所有数据都不会逃逸出去而被其他线程访问到，那就可以认为是线程私有的。）

### 锁粗化

如果一系列连续操作都对同一个对象反复加锁、解锁，甚至在循环中反复加锁、解锁，虚拟机会把同步范围进行扩展。

### 轻量级锁

是相对于使用系统互斥量来实现的传统锁而言的（即传统的锁机制称为重量级锁）。

#### HotSpot 的对象头

HotSpot 的对象头（Object Header）分为两部分：

1. 用于存储对象自身的运行时数据。如 hashCode、GC 分代年龄等。这部分数据长度在 32 位和 64 位虚拟机中分别为 32 bit 和 64 bit，官方称它为 “**Mark Word**”。
2. 用于存储指向方法区对象类型数据的指针。如果是数组对象，还会有一个额外的部分用于存储数组长度。

#### 对象头与轻量级锁

如果对象没有被锁定，虚拟机会先在该线程的栈帧中建立一个锁记录（Lock Record）空间，用于存储对象目前的 Mark Word 的拷贝（官方在这个拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）。

然后，虚拟机将使用 CAS 尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。

如果更新成功，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2 位）将转变为 “00”，即表示对象处于轻量级锁定状态；

如果更新失败，会先检查对象的 Mark Word 是否指向当前线程的栈帧，如果当前线程已经拥有了这个对象的锁，那就直接进入同步块。否则说明已被其他线程抢占；

如果两个以上的线程争用同一个锁，那轻量级锁就不再有效，会变成重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针。后面等待锁的线程将进入阻塞状态。

### 偏向锁

消除数据在无竞争情况下的同步。

如果说轻量级锁是在无竞争情况想使用 CAS 操作消除同步使用的互斥量，那么偏向锁就是在无竞争情况下把整个同步都消除掉，连 CAS 操作都不做了。

如果第一个获取锁的线程，在接下来的执行过程中，他的锁没有被其他线程获取，那么该线程就不会进行同步。

当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设为“01”，即偏向模式。同时用 CAS 把该线程的 ID 记录到 Mark Word 中。如果 CAS 操作成功，该线程以后每次进入这个锁相关的同步锁时（重入），虚拟机都不会再进行同步操作。

当有另一个线程去尝试获取该锁时，偏向模式就会结束，恢复到轻量级锁。

默认开启偏向锁。可通过 -XX:-UseBiasedLocking 来禁止。

