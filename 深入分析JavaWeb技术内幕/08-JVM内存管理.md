# 第8章 JVM内存管理

内存的不同形态：物理内存、虚拟内存。

内存的使用形式：内核空间、用户空间。

​    

## 物理内存与虚拟内存

RAM（随机存储器）。寄存器存中间结果。

连接 CPU 和 RAM 或寄存器的是地址总线。地址总线的宽度决定了处理器一次可以从寄存器或内存中获取多少个 bit，即影响物理地址的索引范围。同时也决定了处理器最大可寻址的地址空间。

如， 32 位地址总线可以寻址的范围是 2^32 个内存位置，每个地址会引用一个字节，所以可以有 4GB 的内存空间。

每个进程运行时会申请内存。各进程之间的内存在逻辑上是独立的，只能访问自己的内存空间。在物理空间上，会使用虚拟内存实现多个进程共享物理内存。

## 内核空间与用户空间

地址空间分为内核空间、用户空间。

程序申请的内存空间就是用户空间的内存。

内核空间主要指操作系统运行时用于程序调度、虚拟内存的使用、连接硬件资源等的程序逻辑。

**划分原因**：为了安全和稳定，使用户程序不能访问操作系统所使用的内存空间。如访问硬件资源只能由操作系统发起，用户程序不能直接访问硬件资源。

如果用户程序要访问硬件资源，如网络连接等，可以调用操作系统提供的接口来实现，这个调用接口的过程就是**系统调用**。每次系统调用都会存在俩那个内存空间的切换。通常的网络传输也是一次系统调用：数据从内核空间接收到远程主机的数据，然后再从内核空间复制到用户空间。

​    

## 在 Java 中哪些组件需要使用内存

Java 中需要分配内存空间的部分。

### Java 堆

JVM 启动时会一次向操作系统申请完堆大小，通过 -Xmx、-Xms 参数控制大小。一旦分配完成，堆的大小就将固定，不能在内存不够时再向操作系统重新申请，也不能在内存空闲时把多余的空间交还给操作系统。

### 线程

每个线程创建时 JVM 会为它创建一个堆栈，堆栈的大小根据不同的 JVM 实现而不同，一般在 256~756KB 之间。

一般会根据 CPU 的核数来分配线程数。

### 类和类加载器

类和类加载器也存储在堆中，这个区域叫永久代（PermGen 区）。

JVM 只会加载那些明确使用的类到内存中，比如加载一个 jar 包时并不会把里面所有类都加载到内存。（-verbose:class 参数可以查看 JVM 加载了哪些类）

一般 JVM 加载一个类只会加载一次。但如果是自己实现的类加载器，就会出现重复加载的情况。所以 PermGen 区需要对已经失效的类做卸载，以免出现内存泄漏。**类被卸载的条件**：

- 在 Java 中没有对表示该类加载器的 java.lang.ClassLoader 对象的引用；
- Java 堆没有表示类加载器加载的类的任何 java.lang.Class 对象的引用；
- 在 Java 堆上该类加载器加载的任何类的所有对象都不再存活、被引用；

而需要注意的是，JVM 创建的 3 个默认类加载器都不可能满足这些条件，因此，任何系统类（如 String）或通过应用程序类加载器（APPClassLoader）加载的任何应用程序类都不能在运行时释放。

### NIO

NIO 使用 java.nio.ByteBuffer.allocateDirect() 方法分配内存，使用的是本机内存而不是 Java 堆上的内存。

ByteBuffer 对象会自动清理本机缓冲区，但这个过程只作为 Java 堆 GC 的一部分来执行。

### JNI

会增加本机内存的占用。

​    

## JVM 内存结构

JVM 中是如何使用内存的。

运行时数据（Runtime Data）：包括 Java 程序本身的数据信息和 JVM 运行 Java 程序需要的额外数据信息，如 PC 指针等。

在 Java 虚拟机规范中，将 Java 运行时数据分为 6 种：

- **PC 寄存器数据**。保存当前正常执行的程序的内存地址。

- **Java 栈**。创建线程时 JVM 会为这个线程创建一个对应的 Java 栈，Java 栈中包含多个栈帧（Frames），每个栈帧与每个方法关联起来的，栈帧中会包含一些方法内定义的内部变量、操作栈、方法返回值等信息。

  Java 栈的栈顶的栈帧就是当前正在执行的活动栈。该栈帧对应的方法结束时的返回值，会变为之前栈帧的操作栈中的一个操作数。

- **堆**。

- **方法区**。存储类结构信息。class 文件被加载到 JVM 时，会被存储在不同的数据结构中，其中的常量池、域、方法数据、方法体、构造函数、类中的专用方法、实例初始化、接口初始化都存储在这个区域。

  方法区也属于 Java 堆中的一部分，即永久区。

- **本地方法区**。除了自定义的本地方法，JVM 在利用 JIT 技术时会将一些 Java 方法重新编译为本地方法代码，这些编译后的本地代码通常也是用本地方法栈来跟踪方法的执行状态的。

- **运行时常量池**。运行时每个 class 文件中的常量表。它包括：编译期的数字常量、方法或域的引用。该区就是方法区的常量池。

​    

## JVM 内存分配策略

先介绍下操作系统通常是怎么分配内存的。

### 通常的内存分配策略

操作系统中的内存分配策略分 3 种：

- **静态内存分配**。在程序编译时就能确定每个数据在运行时的存储空间需求，即编译时就可以给它们分配固定的内存空间。这种分配策略不允许在程序代码中有可变数据结构（如可变数组）的存在，也不允许有嵌套或者递归的结构出现。
- **栈内存分配 / 动态存储分配**。编译时不知道，但运行时必须知道程序所需的数据区大小才能够为其分配内存。
- **堆内存分配**。真正运行到相应代码是才会知道空间大小。

### Java 中的内存分配详解

JVM 内存分配主要基于堆和栈。

栈和线程绑定在一起。栈主要存放一些基本类型数据和对象引用。

创建对象：用 new 指令时 JVM 会为这个对象分配内存空间，此时对象的属性值都是默认值。new 之后对象会开始进行初始化。初始化完成后才会把对象引用赋给变量。

虽然分配是在运行时进行的，但分配的大小是在编译时确定的，运行时不变。

​    

## JVM 内存回收策略

### 静态内存分配和回收

指在编译时就能够确定需要的内存空间，当程序被加载时系统把内存一次性分配给它。

Java 类、方法中的局部变量包括基本数据类型和对象的引用都是静态分配内存的。

静态内存空间就是在 Java 栈上分配的。

### 动态内存分配和回收

### 如何检测垃圾

根对象：

- 方法中局部变量区的对象的引用。
- Java 操作栈中的对象的引用。
- 在常量池中的对象引用。如表示类名的字符串的引用。
- 本地方法中持有的对象引用。有些对象被传入本地方法中，但这些对象还没有被释放。
- 类的 Class 对象。每个类被 JVM 加载时都会创建一个 Class 对象（存放在堆中）。

### 基于分代的垃圾收集算法

主要介绍 Hotspot 中使用的基于分代的垃圾收集方式。

该算法主要思路：对象按寿命长短来分年轻代、年老代。新创建的对象在年轻代，如果对象经过几次回收后仍然存活，那么移到年老代。年老代的收集频度不像年轻代频繁，这样就减少了每次垃圾收集时扫描的对象的数量。

这种设计的思路是：把堆划分成若干个子堆，每个子堆对应一个年龄代。

1. Young 区分为 Eden 区和两个 Survivor 区。新对象会在 Eden 区，当 Eden 区满后会触发 minor GC，将 Eden 区中仍存活的对象复制到一个 Survivor 区中，另一个 Survivor 区中的存活对象也复制到这个 Survivor 区中，以保证始终有一个 Survivor 区是空的。
2. Old 区存放的是 Young 区的 Survivor 满后触发 minor GC 后仍存活的对象，当 Eden 区满之后会将对象放到 Survivor 区，如果 Survivor 区存不下，会将这些对象直接存放到 Old 区。如果 Survivor 区中的对象足够老，也直接存放到 Old 区。如果 Old 区也满了，就会触发 Full GC，回收整个堆内存。
3. Perm 区主要存类的 Class 对象。如果一个类被频繁加载，会导致 Perm 区满，而触发 Full GC。

#### CMS Collector

​    

## 内存问题分析

GC 日志分析

堆快照文件分析

JVM Crash 日志分析

​    

## 实例1

## 实例2

NIO direct memory 内存泄漏

## 实例3

NIO direct memory 内存泄漏

