# 第18章 大浏览量系统的静态化架构设计

​    

## 大浏览量系统的静态改造

### 什么是静态化系统

静态系统特征：

- 通过 URL 能唯一标识一个页面。
- 页面代码中不包含与浏览者相关的因素，如用户姓名、身份标识、Cookie 相关的因素等。
- 页面不包含时间因素（不是指客户端浏览器中获取的时间，而是服务器端输出的时间）。页面结构不能随着时间的变化而变化。如秒杀活动，到某个时间点可以点击购买按钮，这里判断的时间就是从服务器端获取的时间。
- 页面不包含地域因素。即不同地域访问看到的页面应相同。
- 不能包含 Cookie 等私有数据。如果包含这些私有数据，也不可能不包含上面这些因素了。

注：页面不包含指的是 HTML 源码不含有。

### 为什么要进行静态化架构设计

**性能优化为什么要进行静态化架构设计？**

Java 系统本身有其弱点，如不擅长处理大量的连接请求，每个连接消耗的内存较多，Servlet 容器解析 HTTP 较慢等。所以想到了让请求尽量不经过 Java 系统，直接在前面的 Web 服务器层就返回。这种模式自然就需要静态化架构。

**系统静态化为何能做 Java 系统做不到的高性能？**

它的优点：

- 改变了缓存方式。直接缓存 HTTP 连接而不是仅缓存数据。Web 代理服务器根据请求 URL 直接取出对应的 HTTP 响应头和响应体直接返回，这个响应连 HTTP 都不用重新组装，HTTP 请求头也不一定需要解析，所以做到了获取数据最快。
- 改变了缓存的地方。不是在 Java 层面做缓存，而是直接在 Web 服务器层上做。Web 服务器（如 Nginx、Apache 等）都擅长处理大并发的静态文件请求。

### 如何改造动态系统

动态页面改造成静态页面需要去掉那几个影响因素，去掉方法就是做动静态分离。

**动静分离**

- URL 唯一化。如根据商品 ID 做唯一的 URL 标识：xxx.com/item?id=xxx
- 分离与浏览者相关的因素。包括是否登录以及登录身份等信息，可以单独拆分出来，通过动态请求来获取。
- 分离时间因素。服务端输出的时间通过动态请求获取。
- 异步化地域因素。把地域相关的做成异步方式来获取。
- 去掉 Cookie。页面包含的 Cookie 可以通过代码软件来删除。例如 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。

**动态内容结构化**

将动态内容信息 JSON 化。

**如何组装动态内容**

通常有两种获取动态内容的方式：ESI（Edge Side Includes）和 CSI（Client Side Includes）。

- **ESI**。即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中。当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。
- **CSI**。就是发起一个异步 JS请求单独向服务端获取动态内容。这种方式使服务端性能更佳，但是用户端页面有些延时，体验稍差。

### 几种静态化方案的设计及选择

如何设计静态化架构，首先要考虑方案应该遵循的几个原则：

- 是否一致性 Hash 分组？缓存一定和命中率紧密相关。但是一致性 Hash 有天然的缺陷就是会导致热点问题，当热点特别集中时可能会导致网络瓶颈。
- 是否使用 ESI？
- 是否使用物理机？物理机可以提供更大的内存、更好的 CPU 资源，但会导致应用集群的相对集中，进而导致网络风险增加。另外对 Java 系统而言，内存增加并不能带来那么大的好处。
- 谁来压缩、在哪里压缩？增加一层 Cache，必然增加了数据的传输，那么谁来压缩就会影响到 Cache 的容量和网络数据的传输量。
- 网卡选择？即成本问题。

根据这几个方面的考虑，分别得出如下几个方案；

#### 方案1、采用 Nginx + Cache + Java 结构的虚拟机单机部署

浏览器 - LVS - Nginx - Cache（静态文件） - Java

优点：

- 没有网络瓶颈，不需要改造网络；
- 机器增加，也没有网卡瓶颈；
- 机器数增多，故障风险减少；

缺点：

- 机器增加，缓存命中率下降；
- 缓存分散，失效难度增加；
- Cache 和 Java 都会争抢内存；

对解决热点商品访问等问题很有效。

#### 方案2、采用 Nginx + Cache + Java 结构实体机单机部署

方案 1 里的虚拟机改成实体机。Nginx、Cache 做成分布式结构。采用一致性 Hash 分组的方式提升命中率。

#### 方案3、统一 Cache 层

Nginx + Cache 和 Java 层分离。

### 如何解决失效问题

缓存该如何失效。

**被动失效**

设置 Cache 时间长度。对时效性不太敏感的数据的失效。

**主动失效**

有如下几种：

- Cache 失效中心监控数据库表变化，发送 Purge 失效请求；
- 装修时间戳比较失效装修内容；
- Java 系统发布，清空 Cache；
- Vm 模板发布，清空 Cache；

### 服务端静态化方案的演进：CDN 化

将 Cache 移到 CDN 上。因为 CDN 离用户最近，效果会更好。

但要解决这些问题：

- 失效问题。由于 CDN 分布在全国，要在秒级时间内失效这么广泛的 Cache，对 CDN 的失效系统要求很高。
- 命中率问题。Cache 最重要的一个指标就是要保证高命中率。如果数据全放到全国的 CDN 上，Cache 必然会发散，导致命中率降低。
- 发布更新问题。发布是否快速、简单。

那么如何克服这些问题？

**解决失效问题**

由失效中心将失效请求发送给每个 CDN 节点上的 Console 机，然后 Console 机发送 Purge 请求给每台 Cache 机器。

**解决命中率问题**

使用 CDN 的二级 Cache 作为缓存。这样因为节点数不多，Cache 不是很分散。



